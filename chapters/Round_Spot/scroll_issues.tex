\section{Problemy implementacyjne}
Największa trudność napotkana podczas implementacji dotyczyła zbierania danych z obszarów przewijanych (niebieski obszar na diagramie), które nie mieszczą się w całości (wystający fragment) na ekranie aplikacji (ciemnoniebieski prostokąt). Detektor (zielony prostokąt) może zostać umieszczony w drzewie elementów interfejsu na dwa sposoby - jako rodzic obszaru przewijanego lub jego dziecko. W zależności od tego jego pole widzenia i rozmiar będą się różniły. Jeśli jest dzieckiem (znajduje się w środku obszaru) ma dostęp do całej jego zawartości, nawet tej aktualnie niewyświetlonej. W przeciwnym wypadku (będąc rodzicem obszaru) znajduje się na około niego i ``widzi'' jedynie aktualnie wyświetloną na ekranie część.

\img{\chapterPath/scroll-diagram.png}{Możliwości zbierania danych o obszarach przewijanych}{rs_scroll_diagram}{.3}

\subsection{Pierwsze podejście}
Pierwszym wybranym podczas implementacji podejściem było umieszczenie detektora w środku obszaru przewijanego. Dzięki dostępowi do całej zawartości w każdym momencie stworzenie jej obrazu do późniejszego użycia w mapie cieplnej było tak samo łatwe jak w przypadku nieprzewijanych obszarów. Szybko jednak okazało się że to podejście, chociaż proste, ma swoje wady.

Dotknięcia ekranu nazywane też zdarzeniami \ang{events}, są zaimplemenowane we Flutterze podobnie jak w standardzie DOM używanym przez przeglądarki. Po rejestracji przez urządzenie zdarzenie jest przekazywane od korzenia drzewa elementów interfejsu (całej strony) w głąb do kolejnych dzieci zajmujących obszar zawierający współrzędne dotknięcia. Ten proces jest rekurencyjnie powtarzany do czasu gdy zdarzenie zostanie wykorzystane lub przekazane do liścia drzewa. Wykorzystanie oznacza podjęcie akcji takiej jak na przykład naciśnięcie przycisku.

Jedną z możliwych akcji jest gest przewijania obszaru ekranu. W wybranym podejściu w którym detektory są dziećmi elementów przewijanych nie będą otrzymywać informacji o zdarzeniach przewijania, gdyż zostaną one zatrzymywane przez ich rodziców. Ta wada była nie do zaakceptowania z powodu straty dużej ilości potencjalnie interesujących informacji o działaniach użytkownika.

\subsection{Zastosowane rozwiązanie}
Drugim dostępnym podejściem było umieszczenie detektora jako rodzic obszaru przewijanego. Rozwiązało ono problem utraty informacji o przewijaniu ekranu jako że zdarzenia przechodziły przez detektor na drodze do jego dziecka. Rozwiązanie to jest też bardziej ogólne i w przyszłości może pozwolić na znaczne uproszczenie użycia narzędzia przez twórców aplikacji \ref{sec:auto_instrumentation}. 

Z tym podejściem wiąże się jednak duża komplikacja procesu uzyskiwania obrazu tła przewijanego obszaru. Ponieważ detektor ma dostęp tylko i wyłącznie do jego aktualnie wyświetlanej części, podczas przewijania muszą być stale zapisywane kolejne fragmenty ekranu. Te częściowe obrazki wraz z informacją o ich przesunięciu względem górnej krawędzi obszaru są następnie sklejane w jedno spójne tło wykorzystywane przy tworzeniu przewijanych map cieplnych.

Implementacja tego mechanizmu stanowiła wyzwanie na wielu płaszczyznach. Rozwiązanie musiało wspierać zarówno przewijanie w pionie jak i w poziomie. Jednym z jego celów było stworzenie nieprzerwanego tła bez względu na szybkość przewijania ekranu. Aby to osiągnąć moment zapisania kolejnego obrazu tła został uzależniony od części widocznego obszaru która została przewinięta od momentu stworzenia poprzedniego obrazu. Ponieważ aktualne przesunięcie ekranu jest udostępniane przez inny komponent niż wyświetlany obraz te dwie informacje musiały zostać zsynchronizowane aby uniknąć przesunięć w złączonym tle. Szybkie przewijanie ekranu powodowało też wyścigi związane z nadpisywaniem informacji które zostały rozwiązane poprzez stworzenie kolejki asynchronicznie przetwarzającej zapisane fragmenty tła i łączące je w całość.
